 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/rts/Rendering/CMakeLists.txt b/rts/Rendering/CMakeLists.txt
index cb73977a9c35dd5318b305637e47903d86415415..9ed918dbf8913d3a3ca3156541cbf4c7a7e0c3eb 100644
--- a/rts/Rendering/CMakeLists.txt
+++ b/rts/Rendering/CMakeLists.txt
@@ -47,50 +47,51 @@ set(sources_engine_Rendering
 		"${CMAKE_CURRENT_SOURCE_DIR}/Env/Particles/Classes/SmokeProjectile.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Env/Particles/Classes/SmokeProjectile2.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Env/Particles/Classes/SmokeTrailProjectile.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Env/Particles/Classes/SpherePartProjectile.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Env/Particles/Classes/TracerProjectile.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Env/Particles/Classes/WakeProjectile.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Env/Particles/Classes/WreckProjectile.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/FBO.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/StreamBuffer.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/GeometryBuffer.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/glStateDebug.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/glDebugGroup.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/glxHandler.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/LightHandler.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/VertexArray.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/VertexArrayTypes.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/RenderBuffers.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/VBO.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/VAO.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/glExtra.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GL/State.cpp"
                 "${CMAKE_CURRENT_SOURCE_DIR}/GL/myGL.cpp"
                 "${CMAKE_CURRENT_SOURCE_DIR}/Metal/MetalBuffer.cpp"
                 "${CMAKE_CURRENT_SOURCE_DIR}/Metal/MetalTexture.cpp"
                 "${CMAKE_CURRENT_SOURCE_DIR}/Metal/MetalRenderTarget.cpp"
+                "${CMAKE_CURRENT_SOURCE_DIR}/Metal/MetalBackend.mm"
                 "${CMAKE_CURRENT_SOURCE_DIR}/GlobalRendering.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/GroundFlash.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/CommandDrawer.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/HUDDrawer.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/IPathDrawer.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/IconHandler.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/InMapDrawView.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/LineDrawer.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/LuaObjectDrawer.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/SmoothHeightMeshDrawer.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/InfoTexture.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/IInfoTextureHandler.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/Modern/AirLos.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/Modern/Combiner.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/Modern/Height.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/Modern/InfoTextureHandler.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/Modern/Los.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/Modern/Metal.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/Modern/MetalExtraction.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/Modern/Path.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/Modern/ModernInfoTexture.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Map/InfoTexture/Modern/Radar.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Models/3DModel.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Models/3DModelVAO.cpp"
 		"${CMAKE_CURRENT_SOURCE_DIR}/Models/3DOParser.cpp"
diff --git a/rts/Rendering/GL/myGL.cpp b/rts/Rendering/GL/myGL.cpp
index b315e29167c499b0143cdff563072fde1727a88b..fa8585747cef9b2cc77c80f104578a6b6fad0793 100644
--- a/rts/Rendering/GL/myGL.cpp
+++ b/rts/Rendering/GL/myGL.cpp
@@ -1,60 +1,66 @@
 /* This file is part of the Spring engine (GPL v2 or later), see LICENSE.html */
 
 #include <array>
 #include <vector>
 #include <string>
 #include <bit>
 
 #include <SDL.h>
 
 #include "myGL.h"
 #include "VertexArray.h"
 #include "glxHandler.h"
 #include "Rendering/GlobalRendering.h"
 #include "Rendering/GlobalRenderingInfo.h"
 #include "Rendering/Textures/Bitmap.h"
 #include "Rendering/Textures/TextureFormat.h"
 #include "Rendering/GL/VBO.h"
 #include "Rendering/GL/TexBind.h"
 #include "Rendering/IRenderBackend.h"
+#if defined(USE_METAL)
+#include "Rendering/Metal/MetalBackend.h"
+#endif
 #include "System/Log/ILog.h"
 #include "System/Exceptions.h"
 #include "System/StringUtil.h"
 #include "System/SpringMath.h"
 #include "System/Config/ConfigHandler.h"
 #include "System/FileSystem/FileHandler.h"
 #include "System/Platform/MessageBox.h"
 #include "fmt/printf.h"
 
 #include "System/Misc/TracyDefs.h"
 
 #define SDL_BPP(fmt) SDL_BITSPERPIXEL((fmt))
 
 static std::array<CVertexArray, 2> vertexArrays;
 static int currentVertexArray = 0;
 
+// ensure a backend instance exists before any rendering code runs
+[[maybe_unused]] static IRenderBackend& renderBackendInstance = IRenderBackend::Get();
+
 
 /******************************************************************************/
 /******************************************************************************/
 
 CVertexArray* GetVertexArray()
 {
 	RECOIL_DETAILED_TRACY_ZONE;
 	currentVertexArray = (currentVertexArray + 1) % vertexArrays.size();
 	return &vertexArrays[currentVertexArray];
 }
 
 
 /******************************************************************************/
 
 bool CheckAvailableVideoModes()
 {
 	RECOIL_DETAILED_TRACY_ZONE;
 	// Get available fullscreen/hardware modes
 	const int numDisplays = SDL_GetNumVideoDisplays();
 
 	SDL_DisplayMode ddm = {0, 0, 0, 0, nullptr};
 	SDL_DisplayMode cdm = {0, 0, 0, 0, nullptr};
 
 	// ddm is virtual, contains all displays in multi-monitor setups
 	// for fullscreen windows with non-native resolutions, ddm holds
@@ -731,28 +737,70 @@ unsigned int LoadFragmentProgram(const char* filename)
 	RECOIL_DETAILED_TRACY_ZONE;
 
 	return LoadProgram(GL_FRAGMENT_PROGRAM_ARB, filename, "fragment");
 }
 
 
 void glSafeDeleteProgram(GLuint program)
 {
 	if (!GLAD_GL_ARB_vertex_program || (program == 0))
 		return;
 
 	glDeleteProgramsARB(1, &program);
 }
 
 
 /******************************************************************************/
 
 void glClearErrors(const char* cls, const char* fnc, bool verbose)
 {
 	RECOIL_DETAILED_TRACY_ZONE;
 	if (verbose) {
 		for (int count = 0, error = 0; ((error = glGetError()) != GL_NO_ERROR) && (count < 10000); count++) {
 			LOG_L(L_ERROR, "[GL::%s][%s::%s][frame=%u] count=%04d error=0x%x", __func__, cls, fnc, globalRendering->drawFrame, count, error);
 		}
 	} else {
-		for (int count = 0; (glGetError() != GL_NO_ERROR) && (count < 10000); count++);
-	}
-}
\ No newline at end of file
+                for (int count = 0; (glGetError() != GL_NO_ERROR) && (count < 10000); count++);
+        }
+}
+
+
+// ----------------------------------------------------------------------------
+// Render backend factory
+// ----------------------------------------------------------------------------
+
+#if !defined(USE_METAL)
+
+// OpenGL implementation of the render backend
+class GLRenderBackend final : public IRenderBackend {
+public:
+        bool HasExtension(const char* ext) const override { return globalRendering->IsExtensionSupported(ext); }
+        void GetIntegerv(unsigned int param, int* value) const override { glGetIntegerv(param, value); }
+
+        bool GetVideoMemoryInfo(int* memInfo) const override {
+                if (HasExtension("GL_NVX_gpu_memory_info")) {
+                        glGetIntegerv(GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX, &memInfo[0]);
+                        glGetIntegerv(GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX, &memInfo[1]);
+                        return true;
+                }
+
+                if (HasExtension("GL_ATI_meminfo")) {
+                        glGetIntegerv(GL_VBO_FREE_MEMORY_ATI, &memInfo[0]);
+                        glGetIntegerv(GL_TEXTURE_FREE_MEMORY_ATI, &memInfo[1]);
+                        return true;
+                }
+
+                return false;
+        }
+};
+
+#endif // !USE_METAL
+
+IRenderBackend& IRenderBackend::Get()
+{
+#if defined(USE_METAL)
+        static MetalRenderBackend backend;
+#else
+        static GLRenderBackend backend;
+#endif
+        return backend;
+}
diff --git a/rts/Rendering/Metal/MetalBackend.h b/rts/Rendering/Metal/MetalBackend.h
new file mode 100644
index 0000000000000000000000000000000000000000..d158a915d90999c150140ac1feefdfae11dd7529
--- /dev/null
+++ b/rts/Rendering/Metal/MetalBackend.h
@@ -0,0 +1,36 @@
+/* This file is part of the Spring engine (GPL v2 or later), see LICENSE.html */
+
+#pragma once
+
+#ifdef USE_METAL
+
+#include "Rendering/IRenderBackend.h"
+
+#ifdef __OBJC__
+#import <Metal/Metal.h>
+#import <mach/mach.h>
+#else
+class MTLDevice;
+template <typename T> using id = T*;
+struct task_vm_info_data_t;
+#endif
+
+/**
+ * Metal implementation of the generic render backend interface.
+ * The backend exposes minimal queries required by the engine to gather
+ * hardware information without relying on OpenGL entry points.
+ */
+class MetalRenderBackend final : public IRenderBackend {
+public:
+        MetalRenderBackend();
+
+        bool HasExtension(const char* ext) const override;
+        void GetIntegerv(unsigned int param, int* value) const override;
+        bool GetVideoMemoryInfo(int* memInfo) const override;
+
+private:
+        id<MTLDevice> device;
+};
+
+#endif // USE_METAL
+
diff --git a/rts/Rendering/Metal/MetalBackend.mm b/rts/Rendering/Metal/MetalBackend.mm
new file mode 100644
index 0000000000000000000000000000000000000000..a3783e9d00093cfca187df3a4e100a71d658e3f2
--- /dev/null
+++ b/rts/Rendering/Metal/MetalBackend.mm
@@ -0,0 +1,113 @@
+/* This file is part of the Spring engine (GPL v2 or later), see LICENSE.html */
+
+#ifdef USE_METAL
+
+#import <Metal/Metal.h>
+#import <mach/mach.h>
+
+#include "MetalBackend.h"
+
+// Fallback definitions for GL enums queried by the engine.  These values
+// mirror the ones defined by the corresponding OpenGL extensions so that the
+// rest of the engine can issue the same numeric queries regardless of the
+// active backend.
+#ifndef GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX
+#define GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX 0x9048
+#endif
+#ifndef GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX
+#define GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX 0x9049
+#endif
+#ifndef GL_VBO_FREE_MEMORY_ATI
+#define GL_VBO_FREE_MEMORY_ATI 0x87FB
+#endif
+#ifndef GL_TEXTURE_FREE_MEMORY_ATI
+#define GL_TEXTURE_FREE_MEMORY_ATI 0x87FC
+#endif
+
+MetalRenderBackend::MetalRenderBackend()
+{
+        device = MTLCreateSystemDefaultDevice();
+}
+
+bool MetalRenderBackend::HasExtension(const char* /*ext*/) const
+{
+        // Metal does not expose string based extensions; feature queries are
+        // performed through feature sets instead.  Return false to indicate
+        // absence of any GL style extension.
+        return false;
+}
+
+void MetalRenderBackend::GetIntegerv(unsigned int param, int* value) const
+{
+        if (value == nullptr || device == nil)
+                return;
+
+        // Only the subset of queries used by the engine are supported.
+        switch (param) {
+                case GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX: {
+                        if ([device respondsToSelector:@selector(recommendedMaxWorkingSetSize)])
+                                *value = int([device recommendedMaxWorkingSetSize] / 1024);
+                        else
+                                *value = 0;
+                } break;
+
+                case GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX:
+                case GL_VBO_FREE_MEMORY_ATI:
+                case GL_TEXTURE_FREE_MEMORY_ATI: {
+                        size_t total = 0;
+                        size_t used = 0;
+
+                        if ([device respondsToSelector:@selector(recommendedMaxWorkingSetSize)])
+                                total = [device recommendedMaxWorkingSetSize];
+
+                        if ([device respondsToSelector:@selector(currentAllocatedSize)]) {
+                                used = [device currentAllocatedSize];
+                        } else {
+                                task_vm_info_data_t vmInfo;
+                                mach_msg_type_number_t count = TASK_VM_INFO_COUNT;
+                                if (task_info(mach_task_self(), TASK_VM_INFO,
+                                              (task_info_t)&vmInfo, &count) == KERN_SUCCESS) {
+                                        used = vmInfo.phys_footprint;
+                                }
+                        }
+
+                        const size_t freeBytes = (total > used) ? (total - used) : 0;
+                        *value = int(freeBytes / 1024);
+                } break;
+
+                default:
+                        *value = 0;
+                        break;
+        }
+}
+
+bool MetalRenderBackend::GetVideoMemoryInfo(int* memInfo) const
+{
+        if (memInfo == nullptr || device == nil)
+                return false;
+
+        size_t total = 0;
+        size_t used = 0;
+
+        if ([device respondsToSelector:@selector(recommendedMaxWorkingSetSize)])
+                total = [device recommendedMaxWorkingSetSize];
+
+        if ([device respondsToSelector:@selector(currentAllocatedSize)]) {
+                used = [device currentAllocatedSize];
+        } else {
+                task_vm_info_data_t vmInfo;
+                mach_msg_type_number_t count = TASK_VM_INFO_COUNT;
+                if (task_info(mach_task_self(), TASK_VM_INFO,
+                              (task_info_t)&vmInfo, &count) == KERN_SUCCESS) {
+                        used = vmInfo.phys_footprint;
+                }
+        }
+
+        const size_t freeBytes = (total > used) ? (total - used) : 0;
+        memInfo[0] = int(total / 1024);
+        memInfo[1] = int(freeBytes / 1024);
+        return true;
+}
+
+#endif // USE_METAL
+
 
EOF
)
